{"version":3,"file":"nrwl-angular.mjs","sources":["../../src/runtime/nx/data-persistence.ts","../../src/runtime/nx/nx.module.ts","../../nrwl-angular.ts"],"sourcesContent":["import { Injectable, Type } from '@angular/core';\nimport { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { Actions, ofType } from '@ngrx/effects';\nimport { ROUTER_NAVIGATION, RouterNavigationAction } from '@ngrx/router-store';\nimport { Action, Store, ActionCreator } from '@ngrx/store';\nimport { isObservable, Observable, of } from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n  switchMap,\n  withLatestFrom,\n} from 'rxjs/operators';\n\n/**\n * See {@link DataPersistence.pessimisticUpdate} for more information.\n */\nexport interface PessimisticUpdateOpts<T extends Array<unknown>, A> {\n  run(a: A, ...slices: [...T]): Observable<Action> | Action | void;\n  onError(a: A, e: any): Observable<any> | any;\n}\n/**\n * See {@link DataPersistence.pessimisticUpdate} for more information.\n */\nexport interface OptimisticUpdateOpts<T extends Array<unknown>, A> {\n  run(a: A, ...slices: [...T]): Observable<Action> | Action | void;\n  undoAction(a: A, e: any): Observable<Action> | Action;\n}\n\n/**\n * See {@link DataPersistence.fetch} for more information.\n */\nexport interface FetchOpts<T extends Array<unknown>, A> {\n  id?(a: A, ...slices: [...T]): any;\n  run(a: A, ...slices: [...T]): Observable<Action> | Action | void;\n  onError?(a: A, e: any): Observable<any> | any;\n}\n\n/**\n * See {@link DataPersistence.navigation} for more information.\n */\nexport interface HandleNavigationOpts<T extends Array<unknown>> {\n  run(\n    a: ActivatedRouteSnapshot,\n    ...slices: [...T]\n  ): Observable<Action> | Action | void;\n  onError?(a: ActivatedRouteSnapshot, e: any): Observable<any> | any;\n}\n\nexport type ActionOrActionWithStates<T extends Array<unknown>, A> =\n  | A\n  | [A, ...T];\nexport type ActionOrActionWithState<T, A> = ActionOrActionWithStates<[T], A>;\nexport type ActionStatesStream<T extends Array<unknown>, A> = Observable<\n  ActionOrActionWithStates<T, A>\n>;\nexport type ActionStateStream<T, A> = Observable<\n  ActionOrActionWithStates<[T], A>\n>;\n\nexport function pessimisticUpdate<T extends Array<unknown>, A extends Action>(\n  opts: PessimisticUpdateOpts<T, A>\n) {\n  return (source: ActionStatesStream<T, A>): Observable<Action> => {\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.onError))\n    );\n  };\n}\n\nexport function optimisticUpdate<T extends Array<unknown>, A extends Action>(\n  opts: OptimisticUpdateOpts<T, A>\n) {\n  return (source: ActionStatesStream<T, A>): Observable<Action> => {\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.undoAction))\n    );\n  };\n}\n\nexport function fetch<T extends Array<unknown>, A extends Action>(\n  opts: FetchOpts<T, A>\n) {\n  return (source: ActionStatesStream<T, A>): Observable<Action> => {\n    if (opts.id) {\n      const groupedFetches = source.pipe(\n        mapActionAndState(),\n        groupBy(([action, ...store]) => {\n          return opts.id(action, ...store);\n        })\n      );\n\n      return groupedFetches.pipe(\n        mergeMap((pairs) =>\n          pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))\n        )\n      );\n    }\n\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.onError))\n    );\n  };\n}\n\nexport function navigation<T extends Array<unknown>, A extends Action>(\n  component: Type<any>,\n  opts: HandleNavigationOpts<T>\n) {\n  return (source: ActionStatesStream<T, A>) => {\n    const nav = source.pipe(\n      mapActionAndState(),\n      filter(([action]) => isStateSnapshot(action)),\n      map(([action, ...slices]) => {\n        if (!isStateSnapshot(action)) {\n          // Because of the above filter we'll never get here,\n          // but this properly type narrows `action`\n          return;\n        }\n\n        return [\n          findSnapshot(component, action.payload.routerState.root),\n          ...slices,\n        ] as [ActivatedRouteSnapshot, ...T];\n      }),\n      filter(([snapshot]) => !!snapshot)\n    );\n\n    return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n\nfunction isStateSnapshot(\n  action: any\n): action is RouterNavigationAction<RouterStateSnapshot> {\n  return action.type === ROUTER_NAVIGATION;\n}\n\nfunction runWithErrorHandling<T extends Array<unknown>, A, R>(\n  run: (a: A, ...slices: [...T]) => Observable<R> | R | void,\n  onError: any\n) {\n  return ([action, ...slices]: [A, ...T]): Observable<R> => {\n    try {\n      const r = wrapIntoObservable(run(action, ...slices));\n      return r.pipe(catchError((e) => wrapIntoObservable(onError(action, e))));\n    } catch (e) {\n      return wrapIntoObservable(onError(action, e));\n    }\n  };\n}\n\n/**\n * @whatItDoes maps Observable<Action | [Action, State]> to\n * Observable<[Action, State]>\n */\nfunction mapActionAndState<T extends Array<unknown>, A>() {\n  return (source: Observable<ActionOrActionWithStates<T, A>>) => {\n    return source.pipe(\n      map((value) => normalizeActionAndState(value) as [A, ...T])\n    );\n  };\n}\n\n/**\n * @whatItDoes Normalizes either a bare action or an array of action and slices\n * into an array of action and slices (or undefined)\n */\nfunction normalizeActionAndState<T extends Array<unknown>, A>(\n  args: ActionOrActionWithStates<T, A>\n): [A, ...T] {\n  let action: A, slices: T;\n\n  if (args instanceof Array) {\n    [action, ...slices] = args;\n  } else {\n    slices = [] as T;\n    action = args;\n  }\n\n  return [action, ...slices];\n}\n\n/**\n * @whatItDoes Provides convenience methods for implementing common operations of persisting data.\n */\n@Injectable()\nexport class DataPersistence<T> {\n  constructor(public store: Store<T>, public actions: Actions) {}\n\n  /**\n   *\n   * @whatItDoes Handles pessimistic updates (updating the server first).\n   *\n   * Update the server implemented naively suffers from race conditions and poor error handling.\n   *\n   * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n   *     // provides an action and the current state of the store\n   *     run(a, state) {\n   *       // update the backend first, and then dispatch an action that will\n   *       // update the client side\n   *       return this.backend(state.user, a.payload).map(updated => ({\n   *         type: 'TODO_UPDATED',\n   *         payload: updated\n   *       }));\n   *     },\n   *\n   *     onError(a, e: any) {\n   *       // we don't need to undo the changes on the client side.\n   *       // we can dispatch an error, or simply log the error here and return `null`\n   *       return null;\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * Note that if you don't return a new action from the run callback, you must set the dispatch property\n   * of the effect to false, like this:\n   *\n   * ```\n   * class TodoEffects {\n   *   @Effect({dispatch: false})\n   *   updateTodo; //...\n   * }\n   * ```\n   */\n  pessimisticUpdate<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: PessimisticUpdateOpts<[T], A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      pessimisticUpdate(opts)\n    );\n  }\n\n  /**\n   *\n   * @whatItDoes Handles optimistic updates (updating the client first).\n   *\n   * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,\n   * the developer already updated the state locally, so the developer must provide an undo action.\n   *\n   * The error handling must be done in the callback, or by means of the undo action.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload);\n   *     },\n   *\n   *     undoAction: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *       return ({\n   *         type: 'UNDO_UPDATE_TODO',\n   *         payload: a\n   *       });\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * Note that if you don't return a new action from the run callback, you must set the dispatch property\n   * of the effect to false, like this:\n   *\n   * ```\n   * class TodoEffects {\n   *   @Effect({dispatch: false})\n   *   updateTodo; //...\n   * }\n   * ```\n   */\n  optimisticUpdate<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: OptimisticUpdateOpts<[T], A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      optimisticUpdate(opts)\n    );\n  }\n\n  /**\n   *\n   * @whatItDoes Handles data fetching.\n   *\n   * Data fetching implemented naively suffers from race conditions and poor error handling.\n   *\n   * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload).map(r => ({\n   *         type: 'TODOS',\n   *         payload: r\n   *       });\n   *     },\n   *\n   *     onError: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * This is correct, but because it set the concurrency to 1, it may not be performant.\n   *\n   * To fix that, you can provide the `id` function, like this:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {\n   *     id: (a, state) => {\n   *       return a.payload.id;\n   *     }\n   *\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload).map(r => ({\n   *         type: 'TODO',\n   *         payload: r\n   *       });\n   *     },\n   *\n   *     onError: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *       return null;\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.\n   *\n   * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,\n   * it will only run the last one.\n   */\n  fetch<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: FetchOpts<[T], A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      fetch(opts)\n    );\n  }\n\n  /**\n   * @whatItDoes Handles data fetching as part of router navigation.\n   *\n   * Data fetching implemented naively suffers from race conditions and poor error handling.\n   *\n   * `navigation` addresses these problems.\n   *\n   * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`\n   * callback. It provides the activated snapshot associated with the component and the current state. And it only runs\n   * the last request.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodo = this.s.navigation(TodoComponent, {\n   *     run: (a, state) => {\n   *       return this.backend.fetchTodo(a.params['id']).map(todo => ({\n   *         type: 'TODO_LOADED',\n   *         payload: todo\n   *       }));\n   *     },\n   *     onError: (a, e: any) => {\n   *       // we can log and error here and return null\n   *       // we can also navigate back\n   *       return null;\n   *     }\n   *   });\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   */\n  navigation(\n    component: Type<any>,\n    opts: HandleNavigationOpts<[T]>\n  ): Observable<any> {\n    return this.actions.pipe(\n      withLatestFrom(this.store),\n      navigation(component, opts)\n    );\n  }\n}\n\nfunction findSnapshot(\n  component: Type<any>,\n  s: ActivatedRouteSnapshot\n): ActivatedRouteSnapshot {\n  if (s.routeConfig && s.routeConfig.component === component) {\n    return s;\n  }\n  for (const c of s.children) {\n    const ss = findSnapshot(component, c);\n    if (ss) {\n      return ss;\n    }\n  }\n  return null;\n}\n\nfunction wrapIntoObservable<O>(obj: Observable<O> | O | void): Observable<O> {\n  if (isObservable(obj)) {\n    return obj;\n  } else if (!obj) {\n    return of();\n  } else {\n    return of(obj as O);\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { DataPersistence } from './data-persistence';\n\n/**\n * @whatItDoes Provides services for enterprise Angular applications.\n *\n * See {@link DataPersistence} for more information.\n */\n@NgModule({})\nexport class NxModule {\n  static forRoot(): ModuleWithProviders<NxModule> {\n    return { ngModule: NxModule, providers: [DataPersistence] };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}