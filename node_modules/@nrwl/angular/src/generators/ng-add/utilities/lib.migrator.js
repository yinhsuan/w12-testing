"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LibMigrator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const linter_1 = require("@nrwl/linter");
const generators_1 = require("@nrwl/workspace/generators");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const path_1 = require("path");
const dependencies_1 = require("../../utils/dependencies");
const project_migrator_1 = require("./project.migrator");
const validation_logging_1 = require("./validation-logging");
class LibMigrator extends project_migrator_1.ProjectMigrator {
    constructor(tree, options, project, logger) {
        var _a, _b;
        super(tree, options, project, 'libs', logger);
        this.supportedBuilders = {
            build: '@angular-devkit/build-angular:ng-packagr',
            test: '@angular-devkit/build-angular:karma',
            lint: '@angular-eslint/builder:lint',
        };
        this.targetNames = {};
        this.collectTargetNames();
        if (this.targetNames.lint) {
            this.oldEsLintConfigPath =
                (_b = (_a = this.projectConfig.targets[this.targetNames.lint].options) === null || _a === void 0 ? void 0 : _a.eslintConfig) !== null && _b !== void 0 ? _b : (0, devkit_1.joinPathFragments)(this.project.oldRoot, '.eslintrc.json');
            this.newEsLintConfigPath = this.convertRootPath(this.oldEsLintConfigPath);
        }
    }
    migrate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.moveProjectFiles();
            yield this.updateProjectConfiguration();
            this.updateNgPackageJson();
            this.updateTsConfigs();
            this.updateEsLintConfig();
            this.updateCacheableOperations();
            (0, dependencies_1.addBuildableLibrariesPostCssDependencies)(this.tree);
        });
    }
    validate() {
        var _a, _b;
        const result = [];
        // check project root
        if (!this.tree.exists(this.projectConfig.root)) {
            result.push({
                message: `The project root "${this.project.oldRoot}" could not be found.`,
                hint: `Make sure the value for "projects.${this.project.name}.root" is correct ` +
                    `or remove the project if it is not valid.`,
            });
        }
        // check project source root
        if (this.projectConfig.sourceRoot &&
            !this.tree.exists(this.projectConfig.sourceRoot)) {
            result.push({
                message: `The project source root "${this.project.oldSourceRoot}" could not be found.`,
                hint: `Make sure the value for "projects.${this.project.name}.sourceRoot" is correct ` +
                    `or remove the project if it is not valid.`,
            });
        }
        // check for usage of unsupported builders
        const allSupportedBuilders = [
            this.supportedBuilders.build,
            this.supportedBuilders.test,
            this.supportedBuilders.lint,
        ];
        const unsupportedBuilders = [];
        Object.entries((_a = this.projectConfig.targets) !== null && _a !== void 0 ? _a : {}).forEach(([targetName, target]) => {
            if (!allSupportedBuilders.includes(target.executor)) {
                unsupportedBuilders.push([targetName, target.executor]);
            }
        });
        if (unsupportedBuilders.length) {
            result.push({
                messageGroup: {
                    title: 'Unsupported builders',
                    messages: unsupportedBuilders.map(([target, builder]) => `The "${target}" target is using an unsupported builder "${builder}".`),
                },
                hint: `The supported builders for libraries are: ${(0, validation_logging_1.arrayToString)(allSupportedBuilders)}.`,
            });
        }
        // check for multiple targets for the same type of target
        const targetsByType = Object.entries((_b = this.projectConfig.targets) !== null && _b !== void 0 ? _b : {}).reduce((acc, [target, { executor }]) => {
            if (this.supportedBuilders.build === executor) {
                acc.build.push(target);
            }
            else if (this.supportedBuilders.test === executor) {
                acc.test.push(target);
            }
            else if (this.supportedBuilders.lint === executor) {
                acc.lint.push(target);
            }
            return acc;
        }, { build: [], lint: [], test: [] });
        ['build', 'lint', 'test'].forEach((targetType) => {
            if (targetsByType[targetType].length <= 1) {
                return;
            }
            result.push({
                message: `There is more than one target using a builder that is used to ${targetType} the project (${(0, validation_logging_1.arrayToString)(targetsByType[targetType])}).`,
                hint: `Make sure the project only has one target with a builder that is used to ${targetType} the project.`,
            });
        });
        return result.length ? result : null;
    }
    collectTargetNames() {
        var _a;
        Object.entries((_a = this.projectConfig.targets) !== null && _a !== void 0 ? _a : {}).forEach(([targetName, target]) => {
            if (!this.targetNames.build &&
                this.supportedBuilders.build === target.executor) {
                this.targetNames.build = targetName;
            }
            else if (!this.targetNames.test &&
                this.supportedBuilders.test === target.executor) {
                this.targetNames.test = targetName;
            }
            else if (!this.targetNames.lint &&
                this.supportedBuilders.lint === target.executor) {
                this.targetNames.lint = targetName;
            }
        });
    }
    moveProjectFiles() {
        this.moveDir(this.project.oldRoot, this.project.newRoot);
    }
    updateProjectConfiguration() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.projectConfig.root = this.project.newRoot;
            this.projectConfig.sourceRoot = this.project.newSourceRoot;
            if (!this.projectConfig.targets ||
                !Object.keys(this.projectConfig.targets).length) {
                this.logger.warn('The project does not have any targets configured. This might not be an issue. Skipping updating targets.');
            }
            else {
                this.updateBuildTargetConfiguration();
                this.updateLintTargetConfiguration();
                this.updateTestTargetConfiguration();
            }
            (0, devkit_1.updateProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig));
            yield (0, generators_1.convertToNxProjectGenerator)(this.tree, {
                project: this.project.name,
                skipFormat: true,
            });
        });
    }
    updateNgPackageJson() {
        var _a, _b;
        const buildTarget = (_a = this.projectConfig.targets) === null || _a === void 0 ? void 0 : _a[this.targetNames.build];
        if (!((_b = buildTarget === null || buildTarget === void 0 ? void 0 : buildTarget.options) === null || _b === void 0 ? void 0 : _b.project) ||
            !this.tree.exists(buildTarget.options.project)) {
            // we already logged a warning for these cases, so just return
            return;
        }
        const ngPackageJson = (0, devkit_1.readJson)(this.tree, buildTarget.options.project);
        const offset = (0, devkit_1.offsetFromRoot)(this.project.newRoot);
        ngPackageJson.$schema =
            ngPackageJson.$schema &&
                `${offset}node_modules/ng-packagr/ng-package.schema.json`;
        ngPackageJson.dest = `${offset}dist/${this.project.name}`;
        (0, devkit_1.writeJson)(this.tree, buildTarget.options.project, ngPackageJson);
    }
    updateTsConfigs() {
        const rootTsConfigFile = (0, typescript_1.getRootTsConfigPathInTree)(this.tree);
        const projectOffsetFromRoot = (0, devkit_1.offsetFromRoot)(this.projectConfig.root);
        this.updateTsConfigFileUsedByBuildTarget(rootTsConfigFile, projectOffsetFromRoot);
        this.updateTsConfigFileUsedByTestTarget(rootTsConfigFile, projectOffsetFromRoot);
    }
    updateEsLintConfig() {
        if (!this.targetNames.lint || !this.tree.exists(this.newEsLintConfigPath)) {
            return;
        }
        (0, devkit_1.updateJson)(this.tree, this.newEsLintConfigPath, (json) => {
            var _a;
            delete json.root;
            json.ignorePatterns = ['!**/*'];
            const rootEsLintConfigRelativePath = (0, devkit_1.joinPathFragments)((0, devkit_1.offsetFromRoot)(this.projectConfig.root), '.eslintrc.json');
            if (Array.isArray(json.extends)) {
                json.extends = json.extends.map((extend) => this.convertEsLintConfigExtendToNewPath(this.oldEsLintConfigPath, extend));
                // it might have not been extending from the root config, make sure it does
                if (!json.extends.includes(rootEsLintConfigRelativePath)) {
                    json.extends.unshift(rootEsLintConfigRelativePath);
                }
            }
            else {
                json.extends = rootEsLintConfigRelativePath;
            }
            (_a = json.overrides) === null || _a === void 0 ? void 0 : _a.forEach((override) => {
                var _a;
                if (!((_a = override.parserOptions) === null || _a === void 0 ? void 0 : _a.project)) {
                    return;
                }
                override.parserOptions.project = [
                    `${this.projectConfig.root}/tsconfig.*?.json`,
                ];
            });
            return json;
        });
    }
    updateCacheableOperations() {
        var _a;
        const workspaceConfig = (0, devkit_1.readWorkspaceConfiguration)(this.tree);
        Object.keys((_a = workspaceConfig.tasksRunnerOptions) !== null && _a !== void 0 ? _a : {}).forEach((taskRunnerName) => {
            var _a;
            const taskRunner = workspaceConfig.tasksRunnerOptions[taskRunnerName];
            taskRunner.options.cacheableOperations = Array.from(new Set([
                ...((_a = taskRunner.options.cacheableOperations) !== null && _a !== void 0 ? _a : []),
                ...[
                    this.targetNames.build,
                    this.targetNames.lint,
                    this.targetNames.test,
                ].filter(Boolean),
            ]));
        });
        (0, devkit_1.updateWorkspaceConfiguration)(this.tree, workspaceConfig);
    }
    updateBuildTargetConfiguration() {
        var _a, _b, _c, _d, _e;
        if (!this.targetNames.build) {
            this.logger.warn('There is no build target in the project configuration. This might not be an issue. Skipping updating the build configuration.');
            return;
        }
        const buildTarget = this.projectConfig.targets[this.targetNames.build];
        buildTarget.executor = '@nrwl/angular:package';
        if (!buildTarget.options &&
            (!buildTarget.configurations ||
                !Object.keys(buildTarget.configurations).length)) {
            this.logger.warn(`The target "${this.targetNames.build}" is not specifying any options or configurations. Skipping updating the target configuration.`);
            return;
        }
        const buildDevTsConfig = (_b = (_a = buildTarget.options) === null || _a === void 0 ? void 0 : _a.tsConfig) !== null && _b !== void 0 ? _b : (_d = (_c = buildTarget.configurations) === null || _c === void 0 ? void 0 : _c.development) === null || _d === void 0 ? void 0 : _d.tsConfig;
        if (!buildDevTsConfig) {
            this.logger.warn(`The "${this.targetNames.build}" target does not have the "tsConfig" option configured. Skipping updating the tsConfig file.`);
        }
        else if (!this.tree.exists(buildDevTsConfig)) {
            this.logger.warn(`The tsConfig file "${buildDevTsConfig}" specified in the "${this.targetNames.build}" target could not be found. Skipping updating the tsConfig file.`);
        }
        if (!((_e = buildTarget.options) === null || _e === void 0 ? void 0 : _e.project)) {
            this.logger.warn(`The "${this.targetNames.build}" target does not have the "project" option configured. Skipping updating the ng-packagr project file ("ng-package.json").`);
        }
        else if (!this.tree.exists(buildTarget.options.project)) {
            this.logger.warn(`The ng-packagr project file "${buildTarget.options.project}" specified in the "${this.targetNames.build}" target could not be found. Skipping updating the ng-packagr project file.`);
        }
        ['project', 'tsConfig'].forEach((option) => {
            var _a, _b;
            if ((_a = buildTarget.options) === null || _a === void 0 ? void 0 : _a[option]) {
                buildTarget.options[option] = (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(buildTarget.options[option]));
            }
            for (const configuration of Object.values((_b = buildTarget.configurations) !== null && _b !== void 0 ? _b : {})) {
                configuration[option] =
                    configuration[option] &&
                        (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(configuration[option]));
            }
        });
    }
    updateLintTargetConfiguration() {
        if (!this.targetNames.lint) {
            return;
        }
        this.projectConfig.targets[this.targetNames.lint].executor =
            '@nrwl/linter:eslint';
        const lintOptions = this.projectConfig.targets[this.targetNames.lint].options;
        if (!lintOptions) {
            this.logger.warn(`The target "${this.targetNames.lint}" is not specifying any options. Skipping updating the target configuration.`);
            return;
        }
        const existEsLintConfigPath = this.tree.exists(this.newEsLintConfigPath);
        if (!existEsLintConfigPath) {
            this.logger.warn(`The ESLint config file "${this.oldEsLintConfigPath}" could not be found. Skipping updating the file.`);
        }
        lintOptions.eslintConfig =
            lintOptions.eslintConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(lintOptions.eslintConfig));
        lintOptions.lintFilePatterns =
            lintOptions.lintFilePatterns &&
                lintOptions.lintFilePatterns.map((pattern) => this.convertPath(pattern));
        if (!existEsLintConfigPath) {
            return;
        }
        const eslintConfig = (0, devkit_1.readJson)(this.tree, this.newEsLintConfigPath);
        if ((0, linter_1.hasRulesRequiringTypeChecking)(eslintConfig)) {
            lintOptions.hasTypeAwareRules = true;
        }
    }
    updateTestTargetConfiguration() {
        if (!this.targetNames.test) {
            return;
        }
        const testOptions = this.projectConfig.targets[this.targetNames.test].options;
        if (!testOptions) {
            this.logger.warn(`The target "${this.targetNames.test}" is not specifying any options. Skipping updating the target configuration.`);
            return;
        }
        if (!testOptions.tsConfig) {
            this.logger.warn(`The "${this.targetNames.test}" target does not have the "tsConfig" option configured. Skipping updating the tsConfig file.`);
        }
        else if (!this.tree.exists(testOptions.tsConfig)) {
            this.logger.warn(`The tsConfig file "${testOptions.tsConfig}" specified in the "${this.targetNames.test}" target could not be found. Skipping updating the tsConfig file.`);
        }
        testOptions.main = testOptions.main && this.convertAsset(testOptions.main);
        testOptions.polyfills =
            testOptions.polyfills && this.convertAsset(testOptions.polyfills);
        testOptions.tsConfig =
            testOptions.tsConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(testOptions.tsConfig));
        testOptions.karmaConfig =
            testOptions.karmaConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(testOptions.karmaConfig));
        testOptions.assets =
            testOptions.assets &&
                testOptions.assets.map((asset) => this.convertAsset(asset));
        testOptions.styles =
            testOptions.styles &&
                testOptions.styles.map((style) => this.convertAsset(style));
        testOptions.scripts =
            testOptions.scripts &&
                testOptions.scripts.map((script) => this.convertAsset(script));
    }
    updateTsConfigFileUsedByBuildTarget(rootTsConfigFile, projectOffsetFromRoot) {
        var _a, _b, _c, _d;
        if (!this.targetNames.build) {
            return;
        }
        const tsConfigPath = (_b = (_a = this.projectConfig.targets[this.targetNames.build].options) === null || _a === void 0 ? void 0 : _a.tsConfig) !== null && _b !== void 0 ? _b : (_d = (_c = this.projectConfig.targets[this.targetNames.build].configurations) === null || _c === void 0 ? void 0 : _c.development) === null || _d === void 0 ? void 0 : _d.tsConfig;
        if (!tsConfigPath || !this.tree.exists(tsConfigPath)) {
            // we already logged a warning for these cases, so just return
            return;
        }
        this.updateTsConfigFile(tsConfigPath, rootTsConfigFile, projectOffsetFromRoot);
        (0, devkit_1.updateJson)(this.tree, tsConfigPath, (json) => {
            var _a, _b;
            if (!((_a = json.include) === null || _a === void 0 ? void 0 : _a.length) && !((_b = json.files) === null || _b === void 0 ? void 0 : _b.length)) {
                json.include = ['**/*.ts'];
            }
            return json;
        });
    }
    updateTsConfigFileUsedByTestTarget(rootTsConfigFile, projectOffsetFromRoot) {
        var _a;
        if (!this.targetNames.test) {
            return;
        }
        const tsConfig = (_a = this.projectConfig.targets[this.targetNames.test].options) === null || _a === void 0 ? void 0 : _a.tsConfig;
        if (!tsConfig || !this.tree.exists(tsConfig)) {
            // we already logged a warning for these cases, so just return
            return;
        }
        this.updateTsConfigFile(this.projectConfig.targets[this.targetNames.test].options.tsConfig, rootTsConfigFile, projectOffsetFromRoot);
    }
}
exports.LibMigrator = LibMigrator;
//# sourceMappingURL=lib.migrator.js.map